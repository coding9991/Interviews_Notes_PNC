## 1. for循环和while循环各自的优缺点是什么?

for循环初始化和修改都写在语句之前，书写较为简洁，适用于循环次数已知的情况；while初始化在循环体之前，变量修改在循环体中，比较适用于循环次数未知的情况。

## 2. C++标准规定了各个算术类型的最小值，如下表：
| 类型 | 含义| 最小尺寸 |
| --- | --- | --- |
| bool| 布尔类型|未定义|
| char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|Unicode字符|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

某种操作系统下支持的算术类型占用内存如下图所示：
![Alt text](image.png)

## 3.类型转换有哪些方式？各自有什么特点？
旧式风格的显式转化：
```cpp
type(expr); //函数形式的强制类型转换
(type)expr; //C语言风格的强制类型转换
```
现代C++风格的类型转换：
```cpp
cast-type<type>(expr);
```
其中type是待转换的目标类型，expr是被转换的值。
cast-type包括static_cast、dynamic_cast、const_cast和reinterpret_cast四种，表示转换的方式。<br>
**static_cast<br>**
```cpp
static_cast<tpye>(expression);
```
任何编写程序时能够明确的类型转换都可以使用static_cast(static_cast不能转换底层const、volatile和__unaligned属性)，由于不提供运行时的检查，所以叫static_cast，因此在编写程序时要确认转换的安全性。<br>
主要在以下几种场合中使用：

1.用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，将子类对象的指针/引用转换成父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，这种转换是不安全的，需要编写程序时确认；

2.用于基本数据类型之间的转换，例如把int转换为char，int转换为enum等，需要编写程序时确认安全性

3.把void指针转换成目标类型的指针（极其不安全）
```cpp
int i, j;
double slope = static_cast<double>(j)/i;
void *p = &d;
double *p = static_cast<double*>(p);
```
**dynamic_cast**
格式：
```cpp
dynamic_cast<type>(expression);
```
相比static_cast，dynamic_cast会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。使用场景和static_cast类似，在类层次结构中使用，上行转换和其一致，下行转换会检查转换类型，相比static_cast安全。<br>
dynamic_cast转换仅适用于指针或引用，在转换可能发生的前提下，dynamic_cast会尝试转换，若指针转换失败，则返回空指针，若引用转换失败，则抛出异常。
**const_cast**
const_cast用于移除类型的const volatile __unaligned属性，常量指针被转换位非常量指针，并且仍然指向原来的对象；常量引用被转换为非常量引用，并且仍然引用原来的对象。
```cpp
const char *pc;
char *p = const_cast<char*>(pc);
```
**reinterpret_cast**
格式：
```cpp
reinterpret_cast<type>(expression)
```
非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

## 4.什么是完美转发，std::forward()的作用是什么？
std::forward被称为完美转发，它的作用是保持原来的值属性不变。如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。


## 5.什么是左值引用和右值引用，区别是什么？什么是万能引用？
### 左值和右值
可以取地址的表达式是左值，且持久性变量都是左值，反之是右值。左值引用智能绑定左值，使用&修饰被引用对象，右值引用智能绑定右值，通过&&绑定被引对象。

左值是具有标识符、可以取地址的表达式，最常见的情况包括：
- 变量、函数或数据成员
- 返回左值引用的表达是
- 字符串字面值是不可更改的左值
- 如果一个表达式类型是一个左值引用，那么这个表达式就是一个左值

右值就是没有标识符、不可区地址的表达式，一般也称之为临时对象，常见情况有：
- 返回非引用类型的表达式
- 出字符串字面值之外的字面量如42、true

### 左值引用和右值引用
```cpp
int i = 42; //i是左值，可以对i取地址
int &r = i; //r是左值引用，绑定左值i

int &&rr = i; //错误！i是左值，不能绑定到右值引用rr
int &&rr3 = rr; //错误！rr是一个右值引用类型的变量，是一个左值

const std::string &s = "asd"; //ok,常左值引用绑定到右值
```
右值引用无法和右值引用类型变量绑定，因为右值引用类型变量是一个左值，所有持久性变量都是左值。可以取地址的变量是持久性变量，反之是临时性变量。左值引用可以绑定左值引用类型变量，也可以绑定右值引用类型变量。（常左值引用可以绑定到右值）

### 引用折叠和万能引用
引用折叠的两条规则是：
- 一个对右值引用的右值引用会变为一个右值引用
- 所有其他种类的“引用的引用”都会折叠为左值引用

在C++11中，尽管右值引用是使用&&声明的，但&&不一定都是右值引用：
```cpp
Widget&& var1 = someWidget; //"&&"表示右值引用

auto&& var2 = var1; //"&&"表示左值引用

template<typename T>
void f(std::vector<T>&& param); //"&&"不一定表示右值引用

template<typename T>
void f(T&& param);  //"&&"不一定表示右值引用
```
当一个变量或参数被声明为T&&，其中T是被推导的类型，则这个变量或参数就是一个万能引用。

## 6.拷贝构造函数和移动构造函数有什么区别？
移动和拷贝两者最大的区别是：拷贝会产生新的内存，而移动不会。通过拷贝获得的对象状态改变，不会影响到源对象，而通过移动获得的对象状态改变，会影响到源对象，而且被移动的源对象失去所有资源的控制权！拷贝会增加内存申请和数据复制的开销，而移动不会。

## 7.什么是列表初始化，列表初始化有什么优点？
对于部分场合，必须使用列表初始化：
- 类成员中有常量，例如const int a，常量只能被初始化，不能被赋值
- 类成员中有引用，例如int& a，引用只能被初始化，不能被赋值
- 没有operator=的类，不能在构造函数体内直接通过=赋值

列表初始化效率较高：
一个派生类对吸纳更的构造步骤为调用基类构造函数，基类再调用成员变量各自的构造函数，二如果每一层基类/派生类通过初始化列表的方式，则不管继承包裹多少层，完成类成员变量的构造，值调用一次成员自己的构造函数。

## 8.声明和定义有什么区别？
为了支持分离式编译，C++需要将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对哪个名字的声明，而定义负责创建与名字关联的实体。

## 9.引用和指针有什么区别？
指针和引用都是“指向变量”的复合类型，可以实现对其他对象的间接访问。但是存在不同点，其一指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象，而引用只是一个别名，一旦初始化完成引用将和它的初始值对象一直绑定在一起；其二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

## 10.如何避免内存泄漏？
造成内存泄漏的三种常见情况分别是：
- 指针重新赋值
- 错误的内存释放
- 返回值的不正确处理

初始化所有指针、使用智能指针、每一个new都对应delete...

## 11.什么是常量表达式，有什么作用？
常量表达式指值不会改变并且在编译阶段就能得到计算结果的表达式。
以下两种是常量表达式：
```cpp
const int maxSize = 10;
const int limit = maxSize + 1;
```
在一个复杂系统中，很难分辩一个初始值是否为常量表达式，即使在变量前加const，但是赋值是在运行时确定的也不是常量表达式。

C++11中规定，允许将变量声明为constexpr类型以便编译器来验证变量的值是否是一个常量表达式。
- 声明为constexpr的变量一定是一个常量
- 必须用常量表达式初始化

```cpp
constexpr int mf = 20;                  //20是常量表达式
constexpr int limit = mf + 1;           //mf+1是常量表达式
constexpr int sz = size();              //只有当size()是一个constexpr函数时才是一条常量表达式
```
constexpr函数：constexpr函数指能用于常量表达式的函数。定义constexpr函数有几项约定
- 函数的返回值类型及所有的类型都得时字面值类型
- 函数中必须只有一条return语句

```cpp
constexpr int new_sz() {return 40;}     //正确
constexpr int foo = new_sz();           //正确
```

## 12.struct和class有什么区别？
在C++中，struct和class的唯一区别是默认的访问控制。struct默认的成员是public的，而class的默认成员是private的。

## 13.谈一下对工厂模式的理解？

## 14.std::move()的作用是什么，移动语义有什么好处？

## 15.std::vector中，push_back()和emplace_back()的差别是什么，还有什么其他方式向容器中添加元素？
emplace_back 和push_back的区别在于：emplace_back可以通过参数直接就地（in-place）构建对象，同时在源码实现时使用了引用折叠，直接捕获元素类型；push_back的参数需要一个已经存在的对象，如果不存在，需要首先创建一个对象，除非该类对象定义了移动构造函数，否则不支持隐式转换进行元素添加。

因此emplace_back相较于push_back会减少拷贝构造的过程，因此效率会更高。

其他方法包括insert() emplace()等。
```cpp
// iterator emplace(const_iterator pos, args, ...);

// iterator insert(size_t pos, elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。
// iterator insert(size_t pos, n, elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。
// iterator insert(pos, first, last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。
// iterator insert(pos, initlist) 在迭代器 pos 指定的位置之前，插入初始化列表

std::vector<int> v;

v.insert(v.begin(), 8);         //在vector最前面添加元素8
v.insert(v.end(), 7);           //在最后面添加7

v.emplace(v.end(), 6);          //结尾处添加6
```

## 16.为什么类的析构函数需要声明为虚函数？

## 17.指针和引用有什么区别？

## 18.为什么成员变量需要尽可能声明为private？

## 19.常见内置变量占用的内存大小是多少，类对象占用的内存空间如何计算？

## 20.谈一谈C++的内存自动化管理措施？

## 21.谈谈智能指针的原理

## 23.谈谈栈和堆相关知识内容

## 24.shared_ptr有没有可能发生内存泄漏？

## 25.哈希表的底层实现原理是什么？

## 26.什么是内存对齐，为什么要进行内存对齐，内存对齐的规则是什么？

## 27.什么是内存碎片，有哪些途径能减少内存碎片？

## 28.什么是虚拟内存？

## 29.为什么尽可能用非成员函数/非友元函数去替代成员函数？

## 30.为什么函数不能返回一个reference-to-const的结果？

## 31.C++中的转型函数有哪些，分别起到什么作用？

## 32.派生类的虚函数为什么不能通过类型转换调用基函数中的对应函数，正确做法应该是什么？

## 33.当仅有指向派生类的基类指针但需要对派生类内容进行操作时，该如何避免使用dynamic_cast类型转换？

## 34.inline函数的优缺点是什么，底层实现机制是什么？

## 35.多线程的相关内容，什么是互斥锁？

## 36.多态是什么，在程序设计中有什么作用？

## 37.谈一谈template中的隐式接口和编译时多态

## 38.多重继承的缺点是什么？

## 39.什么是齐位技术？齐位有什么优点，在重载new关键字的时候应如何保证齐位？

## 40.为什么有时候需要重载关键字new和delete，有何好处？