## 1. for循环和while循环各自的优缺点是什么?

for循环初始化和修改都写在语句之前，书写较为简洁，适用于循环次数已知的情况；while初始化在循环体之前，变量修改在循环体中，比较适用于循环次数未知的情况。

## 2. C++标准规定了各个算术类型的最小值，如下表：
| 类型 | 含义| 最小尺寸 |
| --- | --- | --- |
| bool| 布尔类型|未定义|
| char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|Unicode字符|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

某种操作系统下支持的算术类型占用内存如下图所示：
![Alt text](image.png)

## 3.类型转换有哪些方式？各自有什么特点？
旧式风格的显式转化：
```cpp
type(expr); //函数形式的强制类型转换
(type)expr; //C语言风格的强制类型转换
```
现代C++风格的类型转换：
```cpp
cast-type<type>(expr);
```
其中type是待转换的目标类型，expr是被转换的值。
cast-type包括static_cast、dynamic_cast、const_cast和reinterpret_cast四种，表示转换的方式。<br>
**static_cast<br>**
```cpp
static_cast<tpye>(expression);
```
任何编写程序时能够明确的类型转换都可以使用static_cast(static_cast不能转换底层const、volatile和__unaligned属性)，由于不提供运行时的检查，所以叫static_cast，因此在编写程序时要确认转换的安全性。<br>
主要在以下几种场合中使用：

1.用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，将子类对象的指针/引用转换成父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，这种转换是不安全的，需要编写程序时确认；

2.用于基本数据类型之间的转换，例如把int转换为char，int转换为enum等，需要编写程序时确认安全性

3.把void指针转换成目标类型的指针（极其不安全）
```cpp
int i, j;
double slope = static_cast<double>(j)/i;
void *p = &d;
double *p = static_cast<double*>(p);
```
**dynamic_cast**
格式：
```cpp
dynamic_cast<type>(expression);
```
相比static_cast，dynamic_cast会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。使用场景和static_cast类似，在类层次结构中使用，上行转换和其一致，下行转换会检查转换类型，相比static_cast安全。<br>
dynamic_cast转换仅适用于指针或引用，在转换可能发生的前提下，dynamic_cast会尝试转换，若指针转换失败，则返回空指针，若引用转换失败，则抛出异常。
**const_cast**
const_cast用于移除类型的const volatile __unaligned属性，常量指针被转换位非常量指针，并且仍然指向原来的对象；常量引用被转换为非常量引用，并且仍然引用原来的对象。
```cpp
const char *pc;
char *p = const_cast<char*>(pc);
```
**reinterpret_cast**
格式：
```cpp
reinterpret_cast<type>(expression)
```
非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

## 4.什么是完美转发，std::forward()的作用是什么？
std::forward被称为完美转发，它的作用是保持原来的值属性不变。如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。


## 5.什么是左值引用和右值引用，区别是什么？什么是万能引用？
### 左值和右值
可以取地址的表达式是左值，且持久性变量都是左值，反之是右值。左值引用智能绑定左值，使用&修饰被引用对象，右值引用智能绑定右值，通过&&绑定被引对象。

左值是具有标识符、可以取地址的表达式，最常见的情况包括：
- 变量、函数或数据成员
- 返回左值引用的表达是
- 字符串字面值是不可更改的左值
- 如果一个表达式类型是一个左值引用，那么这个表达式就是一个左值

右值就是没有标识符、不可区地址的表达式，一般也称之为临时对象，常见情况有：
- 返回非引用类型的表达式
- 出字符串字面值之外的字面量如42、true

### 左值引用和右值引用
```cpp
int i = 42; //i是左值，可以对i取地址
int &r = i; //r是左值引用，绑定左值i

int &&rr = i; //错误！i是左值，不能绑定到右值引用rr
int &&rr3 = rr; //错误！rr是一个右值引用类型的变量，是一个左值

const std::string &s = "asd"; //ok,常左值引用绑定到右值
```
右值引用无法和右值引用类型变量绑定，因为右值引用类型变量是一个左值，所有持久性变量都是左值。可以取地址的变量是持久性变量，反之是临时性变量。左值引用可以绑定左值引用类型变量，也可以绑定右值引用类型变量。（常左值引用可以绑定到右值）

### 引用折叠和万能引用
引用折叠的两条规则是：
- 一个对右值引用的右值引用会变为一个右值引用
- 所有其他种类的“引用的引用”都会折叠为左值引用

在C++11中，尽管右值引用是使用&&声明的，但&&不一定都是右值引用：
```cpp
Widget&& var1 = someWidget; //"&&"表示右值引用

auto&& var2 = var1; //"&&"表示左值引用

template<typename T>
void f(std::vector<T>&& param); //"&&"不一定表示右值引用

template<typename T>
void f(T&& param);  //"&&"不一定表示右值引用
```
当一个变量或参数被声明为T&&，其中T是被推导的类型，则这个变量或参数就是一个万能引用。

## 6.拷贝构造函数和移动构造函数有什么区别？
移动和拷贝两者最大的区别是：拷贝会产生新的内存，而移动不会。通过拷贝获得的对象状态改变，不会影响到源对象，而通过移动获得的对象状态改变，会影响到源对象，而且被移动的源对象失去所有资源的控制权！拷贝会增加内存申请和数据复制的开销，而移动不会。

## 7.什么是列表初始化，列表初始化有什么优点？
对于部分场合，必须使用列表初始化：
- 类成员中有常量，例如const int a，常量只能被初始化，不能被赋值
- 类成员中有引用，例如int& a，引用只能被初始化，不能被赋值
- 没有operator=的类，不能在构造函数体内直接通过=赋值

列表初始化效率较高：
一个派生类对吸纳更的构造步骤为调用基类构造函数，基类再调用成员变量各自的构造函数，二如果每一层基类/派生类通过初始化列表的方式，则不管继承包裹多少层，完成类成员变量的构造，值调用一次成员自己的构造函数。

## 8.声明和定义有什么区别？
为了支持分离式编译，C++需要将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对哪个名字的声明，而定义负责创建与名字关联的实体。

## 9.引用和指针有什么区别？
指针和引用都是“指向变量”的复合类型，可以实现对其他对象的间接访问。但是存在不同点，其一指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象，而引用只是一个别名，一旦初始化完成引用将和它的初始值对象一直绑定在一起；其二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

## 10.如何避免内存泄漏？
造成内存泄漏的三种常见情况分别是：
- 指针重新赋值
- 错误的内存释放
- 返回值的不正确处理

初始化所有指针、使用智能指针、每一个new都对应delete...

## 11.什么是常量表达式，有什么作用？