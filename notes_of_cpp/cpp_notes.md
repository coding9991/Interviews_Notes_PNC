## 1. for循环和while循环各自的优缺点是什么?

for循环初始化和修改都写在语句之前，书写较为简洁，适用于循环次数已知的情况；while初始化在循环体之前，变量修改在循环体中，比较适用于循环次数未知的情况。

## 2. C++标准规定了各个算术类型的最小值，如下表：
| 类型 | 含义| 最小尺寸 |
| --- | --- | --- |
| bool| 布尔类型|未定义|
| char|字符|8位|
|wchar_t|宽字符|16位|
|char16_t|Unicode字符|16位|
|char32_t|Unicode字符|32位|
|short|短整型|16位|
|int|整型|16位|
|long|长整型|32位|
|long long|长整型|64位|
|float|单精度浮点数|6位有效数字|
|double|双精度浮点数|10位有效数字|
|long double|扩展精度浮点数|10位有效数字|

某种操作系统下支持的算术类型占用内存如下图所示：
![Alt text](image.png)

## 3.类型转换有哪些方式？各自有什么特点？
旧式风格的显式转化：
```cpp
type(expr); //函数形式的强制类型转换
(type)expr; //C语言风格的强制类型转换
```
现代C++风格的类型转换：
```cpp
cast-type<type>(expr);
```
其中type是待转换的目标类型，expr是被转换的值。
cast-type包括static_cast、dynamic_cast、const_cast和reinterpret_cast四种，表示转换的方式。<br>
- **static_cast<br>**
```cpp
static_cast<tpye>(expression);
```
任何编写程序时能够明确的类型转换都可以使用static_cast(static_cast不能转换底层const、volatile和__unaligned属性)，由于不提供运行时的检查，所以叫static_cast，因此在编写程序时要确认转换的安全性。<br>
主要在以下几种场合中使用：

1.用于类层次结构中，父类和子类之间指针和引用的转换；进行上行转换，将子类对象的指针/引用转换成父类指针/引用，这种转换是安全的；进行下行转换，把父类对象的指针/引用转换成子类指针/引用，这种转换是不安全的，需要编写程序时确认；

2.用于基本数据类型之间的转换，例如把int转换为char，int转换为enum等，需要编写程序时确认安全性

3.把void指针转换成目标类型的指针（极其不安全）
```cpp
int i, j;
double slope = static_cast<double>(j)/i;
void *p = &d;
double *p = static_cast<double*>(p);
```
- **dynamic_cast**
格式：
```cpp
dynamic_cast<type>(expression);
```
相比static_cast，dynamic_cast会在运行时检查类型转换是否合法，具有一定的安全性。由于运行时的检查，所以会额外消耗一些性能。**dynamic_cast只能在类层次结构中使用**，上行转换和其一致，下行转换会检查转换类型，相比static_cast安全。<br>
dynamic_cast转换仅适用于指针或引用，在转换可能发生的前提下，dynamic_cast会尝试转换，若指针转换失败，则返回nullptr，若引用转换失败，则抛出std::bad_cast异常。

dynamic_cast只能用于具有多态性的类类型上，或者基类指针/引用和派生类之间的转换。dynamic_cast是通过虚表来判断类的类型的，如果拥有继承关系的两个类没有虚表的话，是无法判断类型的，也就无法进行转换。

- **const_cast**

const_cast用于移除类型的const volatile __unaligned属性，常量指针被转换位非常量指针，并且仍然指向原来的对象；常量引用被转换为非常量引用，并且仍然引用原来的对象。
```cpp
const char *pc;
char *p = const_cast<char*>(pc);
```
**reinterpret_cast**
格式：
```cpp
- reinterpret_cast<type>(expression)
```
非常激进的指针类型转换，在编译期完成，可以转换任何类型的指针，所以极不安全。非极端情况不要使用。

## 4.什么是完美转发，std::forward()的作用是什么？
std::forward()被称为完美转发，它的作用是保持原来的值属性不变。如果原来的值是左值，经std::forward处理后该值还是左值；如果原来的值是右值，经std::forward处理后它还是右值。


## 5.什么是左值引用和右值引用，区别是什么？什么是万能引用？
### 左值和右值
可以取地址的表达式是左值，且持久性变量都是左值，反之是右值。左值引用只能绑定左值，使用&修饰被引用对象，右值引用只能绑定右值，通过&&绑定被引对象。

左值是具有标识符、可以取地址的表达式，最常见的情况包括：
- 变量、函数或数据成员
- 返回左值引用的表达式
- 字符串字面值是不可更改的左值
- 如果一个表达式类型是一个左值引用，那么这个表达式就是一个左值

右值就是没有标识符、不可取地址的表达式，一般也称之为临时对象，常见情况有：
- 返回非引用类型的表达式
- 除字符串字面值之外的字面量如42、true

### 左值引用和右值引用
```cpp
int i = 42; //i是左值，可以对i取地址
int &r = i; //r是左值引用，绑定左值i

int &&rr = i; //错误！i是左值，不能绑定到右值引用rr
int &&rr3 = rr; //错误！rr是一个右值引用类型的变量，是一个左值

const std::string &s = "asd"; //ok,常左值引用绑定到右值
```
右值引用无法和右值引用类型变量绑定，因为右值引用类型变量是一个左值，所有持久性变量都是左值。可以取地址的变量是持久性变量，反之是临时性变量。左值引用可以绑定左值引用类型变量，也可以绑定右值引用类型变量。（常左值引用可以绑定到右值）

### 引用折叠和万能引用
引用折叠的两条规则是：
- 一个对右值引用的右值引用会变为一个右值引用
- 所有其他种类的“引用的引用”都会折叠为左值引用

在C++11中，尽管右值引用是使用&&声明的，但&&不一定都是右值引用：
```cpp
Widget&& var1 = someWidget; //"&&"表示右值引用

auto&& var2 = var1; //"&&"表示左值引用

template<typename T>
void f(std::vector<T>&& param); //"&&"不一定表示右值引用

template<typename T>
void f(T&& param);  //"&&"不一定表示右值引用
```
当一个变量或参数被声明为T&&，其中T是被推导的类型，则这个变量或参数就是一个万能引用。

## 6.拷贝构造函数和移动构造函数有什么区别？
移动和拷贝两者最大的区别是：拷贝会产生新的内存，而移动不会。通过拷贝获得的对象状态改变，不会影响到源对象，而通过移动获得的对象状态改变，会影响到源对象，而且被移动的源对象失去所有资源的控制权！拷贝会增加内存申请和数据复制的开销，而移动不会。

## 7.什么是列表初始化，列表初始化有什么优点？
对于部分场合，必须使用列表初始化：
- 类成员中有常量，例如const int a，常量只能被初始化，不能被赋值
- 类成员中有引用，例如int& a，引用只能被初始化，不能被赋值
- 没有operator=的类，不能在构造函数体内直接通过=赋值

列表初始化效率较高：
一个派生类对象的构造步骤为首先调用基类构造函数，基类再调用成员变量各自的构造函数，二如果每一层基类/派生类通过初始化列表的方式，则不管继承包裹多少层，完成类成员变量的构造只调用一次成员自己的构造函数。

## 8.声明和定义有什么区别？
为了支持分离式编译，C++需要将声明和定义区分开来。声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对哪个名字的声明，而定义负责创建与名字关联的实体。

## 9.引用和指针有什么区别？
指针和引用都是“指向变量”的复合类型，可以实现对其他对象的间接访问。但是存在不同点，其一指针本身就是一个对象，允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象，而引用只是一个别名，一旦初始化完成引用将和它的初始值对象一直绑定在一起；其二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

## 10.如何避免内存泄漏？常用的内存泄漏检验工具有哪些？
造成内存泄漏的三种常见情况分别是：
- 指针重新赋值
- 错误的内存释放
- 返回值的不正确处理

初始化所有指针、使用智能指针、每一个new都对应delete...

Linux平台下Valgrind其中的memcheck功能可以检测未释放内存的使用、对释放后内存的读/写、对已分配内存块尾部的读/写、内存泄漏、不匹配的使用malloc/new free/delete、重复释放内存的错误。

## 11.什么是常量表达式，有什么作用？
常量表达式指值不会改变并且在编译阶段就能得到计算结果的表达式。
以下两种是常量表达式：
```cpp
const int maxSize = 10;
const int limit = maxSize + 1;
```
在一个复杂系统中，很难分辩一个初始值是否为常量表达式，即使在变量前加const，但是赋值是在运行时确定的也不是常量表达式。

C++11中规定，允许将变量声明为constexpr类型以便编译器来验证变量的值是否是一个常量表达式。
- 声明为constexpr的变量一定是一个常量
- 必须用常量表达式初始化

```cpp
constexpr int mf = 20;                  //20是常量表达式
constexpr int limit = mf + 1;           //mf+1是常量表达式
constexpr int sz = size();              //只有当size()是一个constexpr函数时才是一条常量表达式
```
constexpr函数：constexpr函数指能用于常量表达式的函数。定义constexpr函数有几项约定
- 函数的返回值类型及所有的类型都得时字面值类型
- 函数中必须只有一条return语句

```cpp
constexpr int new_sz() {return 40;}     //正确
constexpr int foo = new_sz();           //正确
```

## 12.struct和class有什么区别？
在C++中，struct和class的唯一区别是默认的访问控制。struct默认的成员是public的，而class的默认成员是private的。

## 13.谈一下对工厂模式的理解？
工厂模式核心思想就是针对存在继承关系的类，设计一个工厂类由工厂类来承担接口的功能，创建对应的子类对象，在项目复杂的情况下可以便于子类对象的创建。在Apollo中的ControllerAgent就是一个工厂类，通过读取cfg配置文件来决定创建具体的控制器类执行控制功能。

主要分为简单工厂模式、工厂方法模式、抽象工厂模式。

简单工厂模式：拓展性较差，新增产品需要取修改工厂类。

工厂方法模式：新增产品时，都需要增加一个对应的产品的具体工厂类。

抽象工厂模式：同工厂方法模式一样，新增产品时，都需要增加一个对应的产品的具体工厂类。

## 14.std::move()的作用是什么，移动语义有什么好处？
std::move()的作用是将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。<br>
![深拷贝和move的区别](image-1.png)<br>
move()实际上并不能移动任何东西，它唯一的功能是将一个左值强制转换为一个右值引用 ，使我们可以通过右值引用使用该值，以用于移动语义。强制转换为右值的目的是为了方便实现移动构造。

仅仅转移资源的所有者，将资源的拥有者改为被赋值者，这就是所谓的 move 语义。

## 15.std::vector中，push_back()和emplace_back()的差别是什么，还有什么其他方式向容器中添加元素？
emplace_back 和push_back的区别在于：emplace_back可以通过参数直接就地（in-place）构建对象，同时在源码实现时使用了引用折叠，直接捕获元素类型；push_back的参数需要一个已经存在的对象，如果不存在，需要首先创建一个对象，除非该类对象定义了移动构造函数，否则不支持隐式转换进行元素添加。

因此emplace_back相较于push_back会减少拷贝构造的过程，因此效率会更高。

其他方法包括insert() emplace()等。
```cpp
// iterator emplace(const_iterator pos, args, ...);

// iterator insert(size_t pos, elem) 在迭代器 pos 指定的位置之前插入一个新元素elem，并返回表示新插入元素位置的迭代器。
// iterator insert(size_t pos, n, elem) 在迭代器 pos 指定的位置之前插入 n 个元素 elem，并返回表示第一个新插入元素位置的迭代器。
// iterator insert(pos, first, last) 在迭代器 pos 指定的位置之前，插入其他容器（不仅限于vector）中位于 [first,last) 区域的所有元素，并返回表示第一个新插入元素位置的迭代器。
// iterator insert(pos, initlist) 在迭代器 pos 指定的位置之前，插入初始化列表

std::vector<int> v;

v.insert(v.begin(), 8);         //在vector最前面添加元素8
v.insert(v.end(), 7);           //在最后面添加7

v.emplace(v.end(), 6);          //结尾处添加6
```

## 16.为什么类的析构函数需要声明为虚函数，而构造函数不声明为虚函数？
- 为什么构造函数不能是虚函数？

从存储空间角度，虚函数对应一个vtable，这个vtable是存储在对象的内存空间内的，如果构造函数是虚的，就需要vtable来调用，可是对象还没有实例化，未分配内存空间，也就无法找到vtable，因此构造函数不能是虚函数。

从使用角度，虚函数的作用在于通过父类指针或引用来调用它的时候能变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或引用去调用，因此也就规定了构造函数不能是虚函数。

- 为什么析构函数需要声明为虚函数？

为了避免父类指针指向的子类对象在生命周期结束时，派生类中较父类添加的成员和变量占用的内存未被释放导致内存泄漏

## 17.指针和引用有什么区别？
引用和指针都是符合类型，间接的实现对被引/被指对象内存空间的访问，区别在于引用本质上是个别名，必须进行初始化，并且一旦绑定被引对象后就无法再进行更改；而指针本身就是一个对象，指向的对象可以更改，并且可以不进行初始化。

## 18.为什么成员变量需要尽可能声明为private？
提高封装性，避免用户可以随意操作类的内部成员，便于维护，如果成员变量设置为public，那么需要增加功能或者修改功能时，可能还需要对用户代码进行大量修改，但是声明为private就可以通过添加接口函数来避免这种情况发生。

## 19.类对象占用的内存空间如何计算？
内存对齐：

内存对齐需要遵循的规则：

(1) 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。

(2) 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。

## 20.谈一谈C++的内存自动化管理措施？
1. 自动存储期：C++中局部变量和函数参数具有自动存储期，其内存在作用域结束后会自动释放，这有助于避免手动管理这些变量的内存。
2. RAII（资源获取即初始化）：RAII是一种C++编程惯例，通过在对象的构造函数中获取资源，并在析构函数中释放资源实现资源的自动管理，标准库中的智能指针就是RAII的典型应用。
3. 容器和算法：标准模板库提供了许多内置容器和算法，它们管理底层内存的分配和释放，减轻了手动分配和释放内存的麻烦
4. 字符串类：C++提供了std::string类，封装了字符串的内存管理，避免了手动分配和释放内存的麻烦
5. 移动语义：C++11引入了移动语义，允许对象的资源在传递所有权时被移动而不是复制，从而减少不必要的内存复制操作。
6. 智能指针：C++中智能指针提供自动内存管理，可以在不需要手动释放内存的情况下管理动态分配的内存。
7. 异常安全：C++异常处理机制也有助于内存自动化管理，异常抛出时析构函数被自动调用，确保资源的正确释放，从而避免内存泄漏的情况。

## 21.谈谈智能指针的原理

## 23.谈谈栈和堆相关知识内容，C++中还有什么其他内存区域？
- 栈：由编译器管理分配和回收，存放局部变ᰁ和函数参数。<br>
- 堆：由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。<br>
- 全局/静态存储区：分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。<br>
- 常量存储区：存储常量，⼀般不允许修改。<br>
- 代码区：存放程序的⼆进制代码。<br>

## 24.shared_ptr有没有可能发生内存泄漏？

## 25.哈希表的底层实现原理是什么？

## 26.什么是内存对齐，为什么要进行内存对齐，内存对齐的规则是什么？

## 27.什么是内存碎片，有哪些途径能减少内存碎片？
内存碎片是指未被充分利用的内存空间，这些空间虽然总和足够大，但由于分散在各处，无法分配给大尺寸的对象，从而浪费了内存资源。内存碎片分为两种类型：外部碎片和内部碎片。

外部碎片：外部碎片指的是内存中大块的未使用空间，虽然这些空间的总和足够大，但无法分配给请求的大尺寸对象，因为它们被小块的已使用和未使用空间所分隔。

内部碎片：内部碎片是指由于内存分配粒度较大，而导致分配的内存空间实际上比对象本身所需的空间要多出来的现象。这通常发生在对象的大小与分配的内存块大小之间有差异时，使得分配的内存块中有一部分空间没有被充分利用。

减少内存碎片的途径：

内存池：使用内存池管理内存分配和释放。内存池是一块连续的内存空间，可以在其中分配和释放对象，从而减少内存碎片。这对于需要频繁地分配和释放对象的情况特别有用。

内存对齐：合理地设置对象的内存对齐方式，可以减少内部碎片。通过使用alignas或alignof关键字，可以将对象的内存对齐方式指定为某个特定的值。

使用固定大小的内存块：在某些情况下，可以使用固定大小的内存块，而不是直接分配对象。这可以减少外部碎片，但可能需要更多的管理开销。

循环使用内存：在内存有限的情况下，可以考虑使用循环队列等数据结构，以便重复利用已分配的内存块。

合并和分割内存块：定期合并相邻的小块内存，以便形成更大的内存块，或者在适当的时候将大块内存分割成更小的块，以更好地适应不同大小的对象。

智能指针：使用智能指针（如std::shared_ptr、std::unique_ptr）来管理动态分配的内存，以避免手动内存管理的错误，从而减少内存碎片的可能性。

内存分配器的优化：一些编译器和操作系统提供了优化的内存分配器，可以减少内存碎片。例如，Linux中的jemalloc、tcmalloc等。

## 28.什么是虚拟内存？

## 29.为什么尽可能用非成员函数/非友元函数去替代成员函数？

## 30.为什么函数不能返回一个reference-to-const的结果？

## 31.C++中的转型函数有哪些，分别起到什么作用？

## 32.派生类的虚函数为什么不能通过类型转换调用基函数中的对应函数，正确做法应该是什么？

## 33.当仅有指向派生类的基类指针但需要对派生类内容进行操作时，该如何避免使用dynamic_cast类型转换？

## 34.inline函数的优缺点是什么，底层实现机制是什么？

## 35.多线程的相关内容，什么是互斥锁？

## 36.多态是什么，在程序设计中有什么作用？

## 37.谈一谈template中的隐式接口和编译时多态

## 38.多重继承的缺点是什么？

## 39.什么是齐位技术？齐位有什么优点，在重载new关键字的时候应如何保证齐位？

## 40.为什么有时候需要重载关键字new和delete，有何好处？

## 41.深拷贝和浅拷贝有什么区别？

## 42.什么是野指针，如何避免野指针的出现内存泄漏？
指向非法的内存地址指针叫作野指针（Wild Pointer），也叫悬挂指针（Dangling Pointer），意为无法正常使用的指针。

野指针的出现通常有两个场景，包括使用未初始化的指针和在指针所指向的内存被释放后继续通过指针访问。

野指针有时比较隐蔽，编译器不能发现，为了防止野指针带来的危害，开发人员应该注意以下几点。

（1）C++引入了引用机制，如果使用引用可以达到编程目的，就可以不必使用指针。因为引用在定义的时候，必须初始化，所以可以避免野指针的出现。

（2）如果一定要使用指针，那么需要在定义指针变量的同时对它进行初始化操作。定义时将其置位NULL或者指向一个有名变量。

（3）对指针进行free或者delete操作后，将其设置为NULL。对于使用 free 的情况，常常定义一个宏或者函数 xfree 来代替 free 置空指针：

## 43.什么是空间适配器，目前常用的stl版本是哪种？

## 44.C++ 中的指针参数传递和引⽤参数传递有什么区别？

## 45.static关键字和const关键字

## 46.auto_ptr存在什么问题，为什么被弃用？unique_ptr是如何解决这个问题的？
auto_ptr存在以下问题：

1.不支持数组：auto_ptr只能管理单个对象的所有权，无法管理动态分配的数组。

2.潜在的悬空指针问题：当两个auto_ptr指向同一个对象时，如果其中一个auto_ptr释放了对象的所有权，另一个auto_ptr就会变成悬空指针，导致未定义的行为。

3.不适用于STL容器：auto_ptr的复制行为与STL容器的要求不一致，会导致不可预料的错误。由于上述问题，auto_ptr被弃用，并在C++11中被unique_ptr取代。

unique_ptr通过以下方式解决了auto_ptr的问题：

1.支持数组：unique_ptr可以管理动态分配的数组，提供了专门的构造函数和重载的操作符来处理数组。

2.明确的所有权转移：unique_ptr使用移动语义来明确所有权的转移，避免了悬空指针问题。当一个unique_ptr所有权转移到另一个unique_ptr时，原来的unique_ptr将变为null，确保了对象的唯一所有权。

3.支持STL容器：unique_ptr的复制行为与STL容器的要求一致，可以安全地用于STL容器中。

## 47.C语言和C++有什么区别？